/*********************************************
Project : Test software
**********************************************
Chip type: ATmega164A
Clock frequency: 20 MHz
Compilers:  CVAVR 2.x
*********************************************/

#include <mega164a.h>

#include <stdio.h>
#include <delay.h>  
#include <string.h> 
#include <stdlib.h>
#include "defs.h"    

//*************************************************************************************************
//*********** BEGIN SERIAL STUFF (interrupt-driven, generated by Code Wizard) *********************
//*************************************************************************************************

#ifndef RXB8
#define RXB8 1
#endif

#ifndef TXB8
#define TXB8 0
#endif

#ifndef UPE
#define UPE 2
#endif

#ifndef DOR
#define DOR 3
#endif

#ifndef FE
#define FE 4
#endif

#ifndef UDRE
#define UDRE 5
#endif

#ifndef RXC
#define RXC 7
#endif

#define FRAMING_ERROR (1<<FE)
#define PARITY_ERROR (1<<UPE)
#define DATA_OVERRUN (1<<DOR)
#define DATA_REGISTER_EMPTY (1<<UDRE)
#define RX_COMPLETE (1<<RXC)

// USART0 Receiver buffer
#define RX_BUFFER_SIZE0 8
char rx_buffer0[RX_BUFFER_SIZE0];

#if RX_BUFFER_SIZE0 <= 256
unsigned char rx_wr_index0,rx_rd_index0,rx_counter0;
#else
unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
#endif

// This flag is set on USART0 Receiver buffer overflow
bit rx_buffer_overflow0;

//
unsigned char cnt;  // interrupts count
char key;           // key pressed

char read_keyboard(void);
void write_LED(char a);    
void write_PF(char a);
char read_PF(void);
void MyApplication(void);

//


// USART0 Receiver interrupt service routine
interrupt [USART0_RXC] void usart0_rx_isr(void)
{
char status,data;
status=UCSR0A;
data=UDR0;
if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
   {
   rx_buffer0[rx_wr_index0++]=data;
#if RX_BUFFER_SIZE0 == 256
   // special case for receiver buffer size=256
   if (++rx_counter0 == 0) rx_buffer_overflow0=1;
#else
   if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
   if (++rx_counter0 == RX_BUFFER_SIZE0)
      {
      rx_counter0=0;
      rx_buffer_overflow0=1;
      }
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Get a character from the USART0 Receiver buffer
#define _ALTERNATE_GETCHAR_
#pragma used+
char getchar(void)
{
char data;
while (rx_counter0==0);
data=rx_buffer0[rx_rd_index0++];
#if RX_BUFFER_SIZE0 != 256
if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
#endif
#asm("cli")
--rx_counter0;
#asm("sei")
return data;
}
#pragma used-
#endif

// USART0 Transmitter buffer
#define TX_BUFFER_SIZE0 8
char tx_buffer0[TX_BUFFER_SIZE0];

#if TX_BUFFER_SIZE0 <= 256
unsigned char tx_wr_index0,tx_rd_index0,tx_counter0;
#else
unsigned int tx_wr_index0,tx_rd_index0,tx_counter0;
#endif

// USART0 Transmitter interrupt service routine
interrupt [USART0_TXC] void usart0_tx_isr(void)
{
if (tx_counter0)
   {
   --tx_counter0;
   UDR0=tx_buffer0[tx_rd_index0++];
#if TX_BUFFER_SIZE0 != 256
   if (tx_rd_index0 == TX_BUFFER_SIZE0) tx_rd_index0=0;
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Write a character to the USART0 Transmitter buffer
#define _ALTERNATE_PUTCHAR_
#pragma used+
void putchar(char c)
{
while (tx_counter0 == TX_BUFFER_SIZE0);
#asm("cli")
if (tx_counter0 || ((UCSR0A & DATA_REGISTER_EMPTY)==0))
   {
   tx_buffer0[tx_wr_index0++]=c;
#if TX_BUFFER_SIZE0 != 256
   if (tx_wr_index0 == TX_BUFFER_SIZE0) tx_wr_index0=0;
#endif
   ++tx_counter0;
   }
else
   UDR0=c;
#asm("sei")
}
#pragma used-
#endif
//*************************************************************************************************
//********************END SERIAL STUFF (USART0)  **************************************************
//*************************************************************************************************
//*******   if you need USART1, enable it in Code Wizard and copy coresponding code here  *********
//*************************************************************************************************

/*
 * Timer 1 Output Compare A interrupt is used to blink LED
 */
interrupt [TIM1_COMPA] void timer1_compa_isr(void)
{

cnt=(cnt+1)%50;
if (cnt==0) LED1 = ~LED1; // invert LED  
//
 MyApplication();
}                                  

/*
 * main function of program
 */
void main (void)
{          
unsigned char temp,i;

	Init_initController();  // this must be the first "init" action/call!
	#asm("sei")             // enable interrupts
	LED1 = 1;           	// initial state, will be changed by timer 1

	while(TRUE)
	{   
    }
	/*
    	wdogtrig();	        // call often else processor will reset
		if(rx_counter0)     // if a character is available on serial port USART0
		{
			temp = getchar();
			if(temp == '?') 
				printf("\r\nSwVersion:%d.%d\r\n", SW_VERSION/10, SW_VERSION%10); 
			else
				putchar(temp+1);		// echo back the character + 1 ("a" becomes "b", etc)   
		}             

        if(SW1 == 0)        // pressed
        {
            delay_ms(30);   // debounce switch
            if(SW1 == 0)    
            {                // LED will blink slow or fast
                while(SW1==0)
                    wdogtrig();    // wait for release
                // alternate between values and values/4 for OCR1A register
                // 0186 H / 4 = 0061 H
                // new frequency = old frequency * 4
                if(OCR1AH == 0x01)  
                    {TCNT1H=0; TCNT1L=0; OCR1AH = 0x00; OCR1AL = 0x61;}
                else     
                    {TCNT1H=0; TCNT1L=0; OCR1AH = 0x01; OCR1AL = 0x86;}            
            }                
        }                                       
        
        // measure time intervals on oscilloscope connected to pin TESTP
        for(i=0; i<3; i++) {
            TESTP = 1;
            delay_us(1);
            TESTP = 0;   // may check accuracy of 1us interval on oscilloscope     
        }
    } 
    */
            
}// end main loop 

/*******************************************
My application function

********************************************/
void MyApplication (void)
{
  key=read_keyboard();
if (key!=-1) 
    {
    write_LED(key);
    //write_PF(key); 
    }  
key=read_PF();
//write_LED(key);
write_PF(key);
}

/*******************************************
Other functions

*******************************************/

//obs. pt etapa 2 ?: Ar trebui sa mai adaug un rand pentru codul de oprire a comandei "#" si astfel sa am 5 randuri si 4 coloane, a.i. pe row = 4  & col = 0 cod = 0x10 //pt diez 
// functie care citeste randul, coloana si returneaza codul tastei care a fost apasata 
char read_keyboard(void)
{
// line 0 - PA0,  line 1 - PA1,  line 2 - PA2,  line 3 - PA3 - outputs 
char scan[4]={0xFE,0xFD,0xFB, 0xF7};
char row,col;
char cod=0xFF;

for (row=0; row<4; row++)    // randul se pune singur din acest for pe PORTA (xxxx rrrr), dar coloana o setam noi de la PINA(cccc xxxx)
{
PORTA=scan[row];  
delay_us(1);
// col 0 - PA4,  col 1 - PA5,  col 2 - PA6,  col 3 - PA7 - inputs 
col=PINA>>4; //dc. PINA = cccc xxxx, aceasta intructiune o sa imi shifteze bitii la dreapta si va rezulta =>col = 0000 cccc
if (col!=0x0F)                 // daca ramane 0f -> inseamna ca nu am apasat inca nicio tasta, mergem pe logica negativa, daca apas => 0
    {
    if (col==0x0E) col=0;     // 0000 1110 -> coloana o   obs. : incep indexarea coloanelor si a randurilor de la 0 
    if (col==0x0D) col=1;     // 0000 1101 -> coloana 1
    if (col==0x0B) col=2;     // 0000 1011 -> coloana 2 
    if (col==0x07) col=3;     // 0000 0111 -> coloana 3 
    cod=4*row+col;            // din aceasta instructiune rezulta tasta care a fost apasata
    break;
    }
}
return cod;
}

void write_LED(char a) 
{
// write PORTC bits 7-4 with a 4 bits value a3-a0
char val;
val=a & 0x0F;
PORTC=(PORTC & 0x0F) | (val << 4);
} 
  
void write_PF(char a)
{
// write PORTC bits 3-0 with a 4 bits value a3-a0
char val;
val=a & 0x0F;
PORTC=(PORTC & 0xF0) | val;
}

char read_PF(void)
{
// read PORTB bits 3-0 
char val;
val= PINB & 0x0F;
return val;
}
